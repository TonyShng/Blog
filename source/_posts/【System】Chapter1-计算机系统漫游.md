---
title: '【System】Chapter1:计算机系统漫游'
date: 2021-07-28 17:15:57
categories: "System"
tags:
	- System
urlname:
keywords: System
---

```c
#include<stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

#### 1.1 信息就是位 + 上下文

*源程序*（*源文件*） `hello.c` 由值0 和 1 组成的*位*（*比特*）序列，8个位被组织成一组，称为*字节*。

大部分现代计算机系统都使用 *ASCII* 标准来表示文本符号，即用一个唯一的单字节大小的整数值来表示每个字符。

系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。

#### 1.2 程序被其他程序翻译成不同的格式

Hello.c(源程序 文本) --> 预处理器(cpp) --> hello.i(修改了的源程序 文本) --> 编译器(ccl) --> hello.s(汇编程序 文本) --> 汇编器(as) --> hello.o(可重定位目标程序 二进制) --> 链接器(ld) --> hello(可执行目标程序 二进制)

- **预处理阶段** *预处理器(cpp)* 根据以字符 `#` 开头的命令，修改原始的C程序。即将系统头文件的内容直接插入程序文本中。得到另一个C程序，通常是以 `.i` 作为文件扩展名。
- **编译阶段** *编译器(ccl)* 将文本文件 hello.i 翻译器文本文件 hello.s，它包含一个*汇编语言程序*。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。
- **汇编阶段** *汇编器(as)* 将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做 *可重定位目标程序(relocatable object program)的格式*，并将结果保存在目标文件 hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。
- **链接阶段** 在hello程序调用了printf函数，这个函数存在于一个名为printf.o 的单独的预编译好了的目标文件中，*链接器(ld)*负责将这个文件以某种方式合并到我们的hello.o程序中，得到hello文件，它是一个可执行目标文件(或者称为可执行文件)，可以被加载到内存中，由系统执行。

#### 1.3 了解编译程序如何工作是大有益处的

- **优化程序性能** 为了在C程序中做出好的编码选择，需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。
- **理解链接时出现的错误**
- **避免安全漏洞** 缓冲区溢出

#### 1.4 处理器读并解释存储在内存中的指令

```shell
linux> ./hello
hello, world
linux>
```

Shell 是一个命令行解释器，输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。

##### 1.4.1 系统的硬件组成

1. **总线** 贯穿整个系统的是一组电子管道，称作*总线*，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是*字*(word)。字中的字节数(即字长)是一个基本的系统参数，各个系统中都不尽相同。

2. **I/O设备** I/O(输入/输出)设备是系统与外部世界的联系通道。每个I/O设备都通过一个*控制器*或*适配器*与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器I/O设备本身或者系统的主印制电路板(通常称作主板)上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。

3. **主存** 主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组*动态随机存取存储器(DRAM)*芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。

4. **处理器** *中央处理单元(CPU)* ，简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或*寄存器*)，称为*程序计数器(PC)*。在任何时刻，PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。

   从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

   这类操作围绕着主存、*寄存器文件(register file)*和*算数/逻辑单元(ALU)*进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。

   - **加载**：从主存复制一个字节或者一个字到存储器，以覆盖寄存器原来的内容。
   - **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
   - **操作**：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
   - **跳转**：从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖PC中原来的值。

   我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。

##### 1.4.2 运行 hello 程序

在shell程序输入字符串 `./hello` 后，shell程序将字符串逐一读入寄存器，再把它存放到内存中。然后利用*直接存储器存取(DMA)* 技术将hello目标文件中的代码和数据从磁盘复制到主存。一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将"hello,world\n" 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终现实在屏幕上。

#### 1.5 高速缓存至关重要

系统花费了大量的时间把信息从一个地方挪到另一个地方，因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。而这些年随着半导体技术的进步，这种处理器与主存之间的的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。

针对这种处理器与主存之间的差异，系统设计者采用更小更快的存储设备，称为*高速缓存存储器(cache memory,简称 cache 或高速缓存)*，作为暂时的集结区域，存放处理器近期可能会需要的信息。位于处理器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。进程访问L2的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5～10倍。L1和L2高速缓存是用一种叫做*静态随机访问存储器(SRAM)*的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2和L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分内存操作都能在快速的高速缓存中完成。

这里得出的重要结论之一就是：意识到高速缓存存储器存在的应用程序猿能够利用高速缓存将程序的性能提高一个数量级。

#### 1.6 存储设备形成层次结构

在处理器和一个较大较慢的设备(例如主存)之间插入一个更小更快的存储设备(例如高速缓存)的想法已经成为一个普遍的观念。每个计算机系统中的存储设备都被组织成了一个*存储器层次结构*。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或标记为L0。三层高速缓存L1到L3，占据存储器层次结构的第1层到第3层。主存在第4层，以此类推。

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。

#### 1.7 操作系统管理硬件

我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统。操作系统有两个基本功能：(1)防止硬件被失控的应用程序滥用；(2)向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念(进程、虚拟内存和文件)来实现这两个功能。即文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。

##### 1.7.1 进程

进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行个多进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是*上下文*，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行*上下文切换*，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

从一个进程到另一个进程的转换是由操作系统*内核(kernel)*管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的*系统调用(system call)*指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。

##### 1.7.2 线程

在现代系统中，一个进程实际上可以由多个称为*线程*的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需要，线程存成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多个处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。

##### 1.7.3 虚拟内存

*虚拟内存*时一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为*虚拟地址空间*。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。这里的地址是从下往上增大的。

- **程序代码和数据** 对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。
- **堆** 代码和数据区后紧随着的是运行时*堆*。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 `malloc` 和 `free` 这样的 C 标准库函数时，堆可以在运行时动态地拓展和收缩。
- **栈** 位于用户虚拟地址空间顶部的是*用户栈*，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地拓展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。
- **内核虚拟内存** 地址空间顶部的区域是为了内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。

#### 1.7.4 文件

*文件*就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。

文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。

#### 1.8 系统之间利用网络通信

现在系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个I/O设备。随着Internet这样的全球网络的出现，从一台主机复制信息到另一台主机已经成为计算机系统最重要的用途之一。

#### 1.9 重要主题

系统不仅仅是硬件，系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。

##### 1.9.1 Amadahl 定律

Gene Amdahl，计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。这个观察被称为 *Amdahl定律(Amdahl's law)*。该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。即要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

##### 1.9.2 并发和并行

数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。我们用的术语*并发(concurrency)* 是一个通用的概念，指一个同时具有多个活动的系统；而术语*并行(parallelism)*指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。

1. **线程级并发**

   构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。在以前，这种并发执行只是模拟出来的，是通过一台计算机在它正在执行的进程间快速切换来实现的，这种并发形式允许多个用户同时与系统交互。当然即使处理器在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为*单处理器系统*。

   当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个*多处理器系统*。直到最近，锁着多核处理器和*超线程(hyperthreading)*的出现，这种系统才变得常见。

   多核处理器是将多个CPU(称为"核")集成到一个集成电路芯片上。

   超线程，有时称为*同时多线程(simultaneous multi-threading)*，是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算数运算单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另外的线程。

   多处理器的使用可以从两个方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程的方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过50年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。

2. **指令级并行**

   在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。最近的处理器可以保持每个时钟周期2～4条指令的执行速率。其实每条指令从开始到结束需要长得多的时间，大约20个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达100条指令。在*流水线(pipelining)*中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。

   如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为*超标量(super-scalar)*处理器。大多数现代处理器都支持超标量操作。

3. **单指令、多数据并行**

   在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为*单指令*、*多数据*，即SIMD并行。

   提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C程序中自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC就支持向量数据类型。

##### 1.9.3 计算机系统中抽象的重要性

*抽象*的使用是计算机科学中最重要的概念之一。文件是对I/O设备的抽象，虚拟内存是对程序存储器的抽象，进程是对一个正在运行的程序的抽象。*虚拟机*，提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是IBM在20世纪60年代提出来的，但是最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统或同一操作系统的不同版本设计的程序。

#### 1.10 小结

计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ACSII文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比底层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次的知识，程序员可以优化C程序的性能。

操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：1）文件是对I/O设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和I/O设备的抽象。

最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。



































