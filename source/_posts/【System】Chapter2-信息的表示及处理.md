---
title: '【System】Chapter2:信息的表示及处理'
date: 2021-07-30 08:05:15
categories: "System"
tags:
    - System
urlname:
keywords: System
---

现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为**位**（bit），形成了数字革命的基础。二值信号能够很容易地被表示、存储和传输，例如可以表示为穿孔卡片上有洞或者无洞、导线上的高电压或者低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。

<!-- more -->

孤立的讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释（interpretation），即赋予不同的可能位模式以含义，我们就能够表示任何有限集合的元素。

**无符号**（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。**补码**（two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。浮点数（floating-point）编码是表示实数的科学计数法的以2为基数的版本。计算机用这些不同的表示方法实现算数运算。

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会**溢出**（overflow）。溢出会导致某些令人吃惊的后果。另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律和交换律，计算下面任何一个C表达式，都会得出一致的结果。计算机可能没有产生期望的结果，但是至少它是一致的！

浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值+♾️，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同——整数的表示虽然智能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。

通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属性。为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的可移植性，了解这种属性是非常重要的。后面我们会讲到，大量计算机的安全漏洞都是由于计算机算数运算的微妙细节引发的。在早期，当人们碰巧触发了程序漏洞，只会给人们带来一些不便，但是现在，有众多的黑客企图利用他们能找到的任何漏洞，不经过授权就进入他人的系统。这就要求程序员有更多的责任和义务，去了解他们的程序如何工作，以及如何被迫产生不良的行为。

计算机用几种不同的二进制表示形式来编码数值。通过直接操作数字的位级表示，我们得到了几种进行算术运算的方式。理解这些技术对于理解编译器产生的机器级代码是很重要的，编译器会试图优化算术表达式求值的性能。

#### 2.1 信息存储

大多数计算机使用8位的块，或者**字节**（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的**地址**（address），所有可能地址的集合就称为虚拟地址空间（virtual address space）。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器（DRAM）、内存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

接下来，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的**程序对象**（program object），即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

> 指针是C语言的一个重要特性。它提供了引用数据结构（包括数组）的元素机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。

##### 2.1.1 十六进制表示法

一个字节由8位组成。在二进制表示法中，它的值域是0000 0000 ～ 1111 1111。如果看成十进制整数，它的值域就是 0～255。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以16为基数，或者叫做**十六进制**（hexadecimal）数，来表示位模式。十六进制（简写为'hex'）使用数字 0～9 以及字符 A～F 来表示16个可能的值。

在C语言中，以 0x 或 Ox 开头的数字常量被认为是十六进制的值。字符 A～F 既可以是大写，也可以是小写，甚至可以是大小写混合。

编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间人工转换。二进制和十六进制之间的转换比较简单直接，因为可以执行一个十六进制数字的转换——即四位表示一位。一个简单的窍门是，记住十六进制数字A、C和F相应的十进制值。而对于把十六进制值B、D和E转换成十进制值，则可以通过计算它们与前三个值的相对关系来完成。

> 较大数值的十进制和十六进制之间的转换，最好是让计算机或者计算器来完成。

##### 2.1.2 字数据大小

每台计算机都有一个**字长**（word size），指明指针数据的**标称大小**（normal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长位 w 位的机器而言，虚拟地址的范围为 0 ~ $2^w -1$，程序最多访问$2^w$个字节。

最近这些年，出现了大规模的从32位字长机器到64位字长机器到迁移。这种情况首先出现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在智能手机的处理器上。32位字长限制虚拟地址空间为4千兆字节（写作4GB），也就是说，刚刚超过$4 \times 10^9$字节。扩展到64位字长使得虚拟地址空间为16EB，大约是$1.84 \times 10^{19}$​字节。

大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。我们将程序称为“32位程序”或“64位程序”时，区别在于该程序时如何编译的，而不是其运行的机器类型。

计算机和编译器支持多种不同方式编码的数字格式，如不同长度的整数和浮点数。比如，许多机器都有处理单个字节的指令，也有处理表示为2字节、4字节或者8字节整数的指令，还有些指令支持表示为4字节和8字节的浮点数。

C语言支持整数和浮点数的多种数据格式。有些数据类型的确切字节数依赖于程序是如何被编译的。整数或者为有符号的，即可以表示负数、零和正数；或者为无符号的，即只能表示非负数。C的数据类型char 表示一个单独的字节。尽管"char"是由于它被用来存储文本串中的单个字符这一事实而得名，但它也能被用来存储整数值。数据类型 short、int 和 long 可以提供各种数据大小。即使是为64位系统编译，数据类型 int 通常也只有4个字节。数据类型 long 一般在32位程序中为4字节，在64位程序中则为8字节。

为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 int32_t 和 int64_t，它们分别为4个字节和8个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。

大部分数据类型都编码为有符号数值，除非有前缀关键字 unsigned 或对确定大小的数据类型使用了特定的无符号声明。数据类型 char 是一个例外。尽管大多数编译器和机器将它们视为有符号数，但C标准不保证这一点。相反，正如方括号指示的那样，程序员应该用有符号字符的声明来保证其为一个字节的有符号数值。不过，在很多情况下，程序行为对数据类型 char 是有符号的还是无符号的并不敏感。

程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。C语言标准对不同数据类型的数字范围设置了下界，但是却没有上界。

##### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

排列表示一个对象的字节有两个通用的规则。考虑一个 w 位的整数，其位表示为[x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>1</sub>, x<sub>0</sub>]，其中x<sub>w-1</sub>是最高有效位，而x<sub>0</sub>是最低有效位。假设 w 是8的倍数，这些位就能被分组成为字节，其中最高有效字节包含位[x<sub>w-1</sub>, x<sub>w-2</sub>, ... , x<sub>w-8</sub>]，而最低有效字节包含位[x<sub>7</sub>, x<sub>6</sub>, ... , x<sub>0</sub>]，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则是按照从最高有效字节到最低有效字节到顺序存储。前一种规则——最低有效字节在最前面的方式，成为**小端法**(little endian)。后一种规则——最高有效字节在最前面的方式，称为**大端法**(big endian)。

许多比较新的微处理器是**双端法**(big-endian)，也就是说可以把它们配置成作为大端或者小端的机器运行。然而，实际情况是：一旦选择了特定操作系统，那么字节顺序也就固定下来了。

对于大多数应用程序猿来说，其机器所使用的字节顺序是完全不可见的。无论是哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接受程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。

第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在检查机器级程序时。

字节顺序变得重要的第三种情况是编写规避正常的类型系统的程序时。在C语言中，可以通过使用**强制类型转换**(cast)或**联合**(union)来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用的，甚至是必须的。

##### 2.1.4 表示字符串

C语言中字符串被编码为一个以 null (其值为 0 )的字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符串。在使用ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因此，文本数据比二进制数据具有更强的平台独立性。

> 基本编码，称为 Unicode 的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占4个字节。不过，可以有一些替代编码，常见的字符只需要1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8 表示将每个字符编码为一个字节序列，这样标准 ASCII 字符还是使用和它们在 ASCII 中一样的单字节编码，这也就意味着所有的 ASCII 字节序列用ASCII码表示和用 UTF-8 表示是一样的。

##### 2.1.5 表示代码

当我们在机器上编译，生成字节表示的机器代码，我们会发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

##### 2.1.6 布尔代数简介

二进制值是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经演化出了丰富的数学知识体系。布尔注意到通过将逻辑值TRUE(真)和FALSE(假)编码为二进制值1和0，能够设计出一种代数，以研究逻辑推理的基本原则。

布尔运算 ～ 对应于逻辑运算 NOT，在命题逻辑中用符号¬表示。也就是说，当P不是真的时候，我们就说¬P是真的，反之亦然。相应地，当 P 等于0时， ～P 等于1，反之亦然。布尔运算 & 对应于逻辑运算 AND，在命题逻辑中用符号∧表示。当 P 和 Q都为真时，我们说 P ∧ Q 为真。相应地，当只有 p =1 且 q = 1时，p & q 才等于1。布尔运算 | 对应于逻辑运算 OR ，在命题逻辑中用符号 ∨ 表示。当 P 或者 Q 为真时，我们说 P ∨ Q 成立。相应地，当 p = 1 或者 q = 1 时， p | q 等于1。布尔运算 ^ 对应于逻辑运算异或，在命题逻辑中用符号⊕表示。当 P 或者 Q为真但不同时为真时，我们说 P⊕Q 成立。相应地，当 p=1 且 q=0，或者 p=0 且 q=1时，p^q 等于1。

我们可以将上述4个布尔运算扩展到位向量的运算，位向量就是固定长度为w、由0和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。

> 对于任意整数w>0，长度为w的位向量上的布尔运算 |、& 和~ 形成了一个布尔代数。最简单的情况是 w=1时，只有2个元素；但是对于更普遍的情况，有2<sup>w</sup> 个长度为w的位向量。布尔代数和整数算术运算有很多相似之处。 当考虑长度为 w 的位向量上的 ^、 & 和 ~ 运算时，会得到一种不同的数学形式，我们称为**布尔环**(Boolean ring)。布尔环与整数运算有很多相同的属性。

位向量一个很有用的应用就是表示有限集合。在大量实际应用中，我们都能看到用位向量来对集合编码。

##### 2.1.7 C语言中的位级运算

C语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使用的那些符号就是C语言所使用的：| 就是 OR（或），& 就是 AND（与），～ 就是 NOT（取反），而 ^ 就是 EXCLUSIVE-OR（异或）。这些运算能运行到任何“整型”的数据类型上。确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转回十六进制。

位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。

##### 2.1.8 C 语言中的逻辑运算

C 语言还提供了一组逻辑运算符 ||、&& 和 !，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。它们返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。

按位运算只有在特殊情况下，也就是参数被限制为 0 或者 1 时，才和与其他对应的逻辑运算有相同的行为。

逻辑运算符 && 和 || 与它们对应的位级运算 & 和 | 之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。

##### 2.1.9 C 语言中的移位运算

C 语言还提供了一组**移位**运算。向左或者向右移动位模式。对于一个位表示为 [x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>0</sub>] 的操作数 x，C 表达式 x<<k 会生成一个值，其位表示为 [x<sub>w-k-1</sub>, x<sub>w-k-2</sub>, ..., x<sub>w-1</sub>, 0, ..., 0]。也就是说，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个0。移位量应该是一个 0~w-1 之间的值。移位运算是从左至右可结合的，所以 x<<j<<k 等价于 (x<<j)<<k。

有一个相应的右移运算 x>>k，但是它的行为有点微妙。一般而言，机器支持两种形式的右移：**逻辑右移**和**算术右移**。逻辑右移在最左端补k个0，得到的结果是[0, ..., 0, x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>k</sub>]。算术右移是在左端补 k 个最高有效位的值，得到的结果是[x<sub>w-1</sub>, ..., x<sub>w-1</sub>, x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>k</sub>]。这种做法看上去可能有点奇特，但是我们会发现它对有符号整数数据的运算非常有用。

C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，机会所有的编译器/机器组合都对有符号数使用算数右移，且许多程序猿也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。

 #### 2.2 整数表示

用位来编码整数有两种不同的方式：一种只能表示非负数，而另一种能够表示负数、零和正数。后面我们将会看到它们在数学属性和机器级实现方面密切相关。我们还会研究扩展或者收缩一个已编码整数以适应不同长度表示的效果。

##### 2.2.1 整型数据类型

C 语言支持多种**整形**数据类型——表示有限范围的整数。每种类型都能用关键字来指定大小，这些关键字包括 char、short、long，同时还可以指示被表示的数字是非负数（声明为 unsigned），或者可能是负数（默认）。

为这些不同的大小分配的字节数根据程序编译为 32 位还是 64 位而有所不同。根据字节分配，不同的大小所能表示的值的范围是不同的。这里给出来的唯一一个与机器相关的取值范围是大小指示符 long 的。大多数 64 位机器使用 8 个字节的表示，比 32 位机器上使用的 4 个字节的表示的取值范围大很多。

值得注意的特点是取值范围是不对称的——负数的范围比正数的范围大1。

##### 2.2.2 无符号数的编码

假设有一个整数数据类型有 w 位。我们可以将位向量写成 $\vec x$ ，表示整个向量，或者写成[x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>0</sub>]，表示向量的中的每一位。把 $\vec x$ 看做一个二进制表示的数，就获得了 $\vec x$ 的无符号表示。在这个编码中，每个位 x<sub>i</sub> 都取值为 0 或 1，后一种取值意味着数值 2<sup>i</sup> 应为数字值的一部分。我们用一个函数 B2U<sub>w</sub> （Binary to Unsigned 的缩写，长度为 w ）来表示：

**原理**：无符号数编码的定义

对向量 $\vec x$ = [x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>0</sub>] ： B2U<sub>w</sub>($\vec x$)  $\dot=$ $\sum_{i=0}^{w-1}$x<sub>i</sub> 2<sup>i</sup>

最小值使用位向量 [000...0] 表示，也就是整数值0，而最大值是用位向量 [11...1] 表示，也就是 2<sup>w</sup> -1。

无符号数的二进制表示有一个很重要的属性，也就是每个介于 0~2<sup>w</sup> -1之间的数都有唯一一个 w 位的值编码。即无符号数编码的唯一性。 函数B2U<sub>w</sub> 是一个双射。

##### 2.2.3 补码编码

对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是**补码**（two's-complement）形式。在这个定义中，将字的最高有效位解释为负权(negative weight)。我们用函数B2T<sub>w</sub> (Binary to Two's-complement 的缩写，长度为w)来表示：

原理：补码编码的定义

对向量 $\vec x$ = [x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>0</sub>] ： B2T<sub>w</sub>($\vec x$)  $\dot=$ -x<sub>w-1</sub>2<sup>w-1</sup> + $\sum_{i=0}^{w-1}$x<sub>i</sub> 2<sup>i</sup>

最高有效位 x<sub>w-1</sub> 也称为**符号位**，它的"权重"为 -2<sup>w-1</sup>，是无符号表示中权重的负数。符号为被设置为1时，表示值为负，而当设置为0时，值为非负。

例子 B2T<sub>4</sub>([1011]) = -1 * 2<sup>3</sup> + 0 * 2 <sup>2</sup> + 1 * 2<sup>1</sup> + 1 * 2<sup>0</sup> =  -8 + 0 + 2 + 1 = -5

w位补码所能表示的值的范围。最小值是位向量 [10...0]（也就是设置这个位为负权，但是清除其他所有的位），其整数值为 TMin<sub>w</sub> $\dot =$ -2<sup>w</sup> - 1。而最大值是位向量 [01...1]（清除具有负权的位，而设置其他所有的位），其整数值为 TMax<sub>w</sub> $\dot=$ $\sum_{i=0}^{w-2}$2<sup>i</sup> = 2<sup>w-1</sup> - 1。即以长度为4为例，TMin<sub>4</sub> = B2T<sub>4</sub>([1000]) = -2<sup>3</sup> = -8，而TMax<sub>4</sub> = B2T<sub>4</sub>([0111]) = 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup> = 7。

同时补码编码也具有唯一性，即函数 B2T<sub>w</sub> 是一个双射。

补码的范围是不对称的：|TMin| = |TMax| + 1，也就是说，TMin 没有与之对应的正数。这就导致了补码运算的某些特殊的属性，并且容易造成程序中细微的错误。之所以会有这样的不对称性，是因为一半的位模式（符号位设置为 1 的数）表示负数，而另一半（符号位设置为 0 的数）表示非负数。因为 0 是非负数，也就意味着能表示的整数比负数少一个。第二，最大的无符号数值刚好比补码的最大值的两倍大一点：UMax<sub>w</sub> = 2TMax<sub>w</sub> + 1。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。注意 -1 和 UMax 有同样的位表示——一个全是1的串。数值 0 在两种方式中都是全 0 的串。

C 语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。

##### 2.2.4 有符号数和无符号数之间的转换

C 语言允许在各种不同的数字数据类型之间做强制类型转换。例如，假设变量 x 声明为 int，u 声明为 unsigned。表达式 (unsigned)x 会将 x 的值转换成一个无符号数值，而 (int)u 将 u 的值转换成一个有符号整数。对于在两种形式中都能表示的值，我们是想要保持不变的。另一方面，将负数转换成无符号数可能会得到 0。如果转换的无符号数太大以至于超出了补码能够表示的范围，可能会得到 TMax。不过，对于大多数 C 语言的实现来说，对这个问题的回答都是从位级角度来看的，而不是数的角度。

对于大多数 C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

无符号表示中的 UMax 有着和补码表示的 -1 相同的位模式。我们在这两个数之间也能看到这种关系：1 + UMax<sub>x</sub> = 2<sup>w</sup>。

给定位模式的补码与无符号数之间的关系可以表示为函数 T2U 的一个属性：

**原理**：补码转换为无符号数

对于位模式 $\vec x$ ，如果我们计算 B2U<sub>w</sub>( $\vec x$ ) - B2T<sub>w</sub>( $\vec x$ ) 之差，从 0 到 w-2 的位的加权和将互相抵消掉，剩下一个值: B2U<sub>w</sub>( $\vec x$ ) - B2T<sub>w</sub>( $\vec x$ ) = x<sub>w-1</sub>(2<sup>w-1</sup> - (-2<sup>w-1</sup>)) = x<sub>w-1</sub>2<sup>w</sup> 。这就得到一个关系：B2U<sub>w</sub>( $\vec x$ ) = x<sub>w-1</sub>2<sup>w</sup> + B2T<sub>w</sub>( $\vec x$ )。我们因此就有：

B2U<sub>w</sub>(T2B<sub>w</sub>(x)) = T2U<sub>w</sub>(x) = x + x<sub>w-1</sub>2<sup>w</sup>

在 x 的补码表示中，位 x<sub>w-1</sub> 决定了 x 是否为负。从补码变为无符号数，最高有效位的权重从 -8 变为 +8。因此，补码表示的负数如果看成无符号数，值会增加 2<sup>4</sup> = 16。因而，-5 变成了 +11，而 -1 变成了 +15。

当将一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。





#### 2.3 整数运算

许多刚入门的程序猿非常惊奇地发现，两个正数相加会得出一个负数，而比较表达式 x < y 和比较表达式 x-y<0 会产生不同的结果。这些属性是由计算机运算的有限性造成的。理解计算机运算的细微之处能够帮助程序猿编写更可靠的代码。

##### 2.3.1 无符号加法



























