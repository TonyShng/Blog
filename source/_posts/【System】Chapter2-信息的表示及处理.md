---
title: '【System】Chapter2:信息的表示及处理'
date: 2021-07-30 08:05:15
categories: "System"
tags:
    - System
urlname:
keywords: System
---

现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为*位（bit）*，形成了数字革命的基础。二值信号能够很容易地被表示、存储和传输，例如可以表示为穿孔卡片上有洞或者无洞、导线上的高电压或者低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。

<!-- more -->

孤立的讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释（interpretation），即赋予不同的可能位模式以含义，我们就能够表示任何有限集合的元素。

*无符号*（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。*补码*（two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。浮点数（floating-point）编码是表示实数的科学计数法的以2为基数的版本。计算机用这些不同的表示方法实现算数运算。

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会*溢出*（overflow）。溢出会导致某些令人吃惊的后果。另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律和交换律，计算下面任何一个C表达式，都会得出一致的结果。计算机可能没有产生期望的结果，但是至少它是一致的！

浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值+♾️，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同——整数的表示虽然智能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。

通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属性。为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的可移植性，了解这种属性是非常重要的。后面我们会讲到，大量计算机的安全漏洞都是由于计算机算数运算的微妙细节引发的。在早期，当人们碰巧触发了程序漏洞，只会给人们带来一些不便，但是现在，有众多的黑客企图利用他们能找到的任何漏洞，不经过授权就进入他人的系统。这就要求程序员有更多的责任和义务，去了解他们的程序如何工作，以及如何被迫产生不良的行为。

计算机用几种不同的二进制表示形式来编码数值。通过直接操作数字的位级表示，我们得到了几种进行算术运算的方式。理解这些技术对于理解编译器产生的机器级代码是很重要的，编译器会试图优化算术表达式求值的性能。

#### 2.1 信息存储

大多数计算机使用8位的块，或者*字节*（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为*虚拟内存*（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的*地址*（address），所有可能地址的集合就称为虚拟地址空间（virtual address space）。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器（DRAM）、内存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

接下来，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的*程序对象*（program object），即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

> 指针是C语言的一个重要特性。它提供了引用数据结构（包括数组）的元素机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。

##### 2.1.1 十六进制表示法

一个字节由8位组成。在二进制表示法中，它的值域是0000 0000 ～ 1111 1111。如果看成十进制整数，它的值域就是 0～255。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以16为基数，或者叫做*十六进制*（hexadecimal）数，来表示位模式。十六进制（简写为'hex'）使用数字 0～9 以及字符 A～F 来表示16个可能的值。

在C语言中，以 0x 或 Ox 开头的数字常量被认为是十六进制的值。字符 A～F 既可以是大写，也可以是小写，甚至可以是大小写混合。

编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间人工转换。二进制和十六进制之间的转换比较简单直接，因为可以执行一个十六进制数字的转换——即四位表示一位。一个简单的窍门是，记住十六进制数字A、C和F相应的十进制值。而对于把十六进制值B、D和E转换成十进制值，则可以通过计算它们与前三个值的相对关系来完成。

> 较大数值的十进制和十六进制之间的转换，最好是让计算机或者计算器来完成。

##### 2.1.2 字数据大小

每台计算机都有一个*字长*（word size），指明指针数据的*标称大小*（normal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长位 w 位的机器而言，虚拟地址的范围为 0 ~ $2^w -1$，程序最多访问$2^w$个字节。

最近这些年，出现了大规模的从32位字长机器到64位字长机器到迁移。这种情况首先出现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在智能手机的处理器上。32位字长限制虚拟地址空间为4千兆字节（写作4GB），也就是说，刚刚超过$4 \times 10^9$字节。扩展到64位字长使得虚拟地址空间为16EB，大约是$1.84 \times 10^{19}$​字节。

大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。

































